//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;DEFINITIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.ARCH armv8-a
.EQU LOAD_ADDRESS, 0X8000
.EQU CODE_SIZE, (END-END_HEADER) // EVERYTHING BEYOND THE HEADER IS CODE

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;HEADER;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELF_HEADER:
	.BYTE 0X7F,'E','L','F' // MAGIC NUMBER TO INDICATE ELF FILE
	.BYTE 0X02 // 0X1 FOR 32-BIT, 0X2 FOR 64-BIT
	.BYTE 0X01 // 0X1 FOR LITTLE ENDIAN, 0X2 FOR BIG ENDIAN
	.BYTE 0X01 // 0X1 FOR CURRENT VERSION OF ELF
	.BYTE 0X00 // 0X9 FOR FREEBSD, 0X3 FOR LINUX (DOESN'T SEEM TO MATTER)
	.BYTE 0X00 // ABI VERSION (IGNORED?)
	.FILL 7, 1, 0X00 // 7 PADDING BYTES
	.SHORT 0X0002 // EXECUTABLE FILE
	.SHORT 0X00B7 // ARMV8A
	.WORD 0X00000001 // VERSION 1
	.QUAD LOAD_ADDRESS+(START-ELF_HEADER) // ENTRY POINT FOR OUR PROGRAM
	.QUAD 0X0000000000000040 // 0X40 OFFSET FROM TO PROGRAM_HEADER
	.QUAD 0X0000000000000000 // SECTION HEADER OFFSET (WE DON'T HAVE THIS)
	.WORD 0X00000000 // UNUSED FLAGS
	.SHORT 0X0040 // 64-BYTE SIZE OF ELF_HEADER
	.SHORT 0X0038 // 56-BYTE SIZE OF EACH PROGRAM HEADER ENTRY
	.SHORT 0X0001 // NUMBER OF PROGRAM HEADER ENTRIES (WE HAVE ONE)
	.SHORT 0X0000 // SIZE OF EACH SECTION HEADER ENTRY (NONE)
	.SHORT 0X0000 // NUMBER OF SECTION HEADER ENTRIES (NONE)
	.SHORT 0X0000 // INDEX IN SECTION HEADER TABLE FOR SECTION NAMES (WASTE)
PROGRAM_HEADER:
	.WORD 0X00000001 // 0X1 FOR LOADABLE PROGRAM SEGMENT
	.WORD 0X00000007 // READ/WRITE/EXECUTE FLAGS
	.QUAD 0X0000000000000078 // OFFSET OF CODE START IN FILE IMAGE
	.QUAD LOAD_ADDRESS+0X78 // VIRTUAL ADDRESS OF SEGMENT IN MEMORY
	.QUAD 0X0000000000000000 // PHYSICAL ADDRESS OF SEGMENT IN MEMORY
	.QUAD CODE_SIZE // SIZE (BYTES) OF SEGMENT IN FILE IMAGE
	.QUAD CODE_SIZE+BUFFER_SIZE // SIZE (BYTES) OF SEGMENT IN MEMORY
	.QUAD 0X0000000000000000 // ALIGNMENT (DOESN'T MATTER, ONLY 1 SEGMENT)
END_HEADER:

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;INCLUDES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

//.EQU VERBOSE_LOGS, 1

.INCLUDE "SYS/EXIT.S"

.INCLUDE "SYS/LINUX/SYSCALLS.S"
.INCLUDE "IO/LOG_FILE.S"

.INCLUDE "SYS/OPEN.S"
.INCLUDE "SYS/READ.S"
.INCLUDE "SYS/WRITE.S"
.INCLUDE "SYS/UNLINK.S"
.INCLUDE "SYS/LSEEK.S"

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;INSTRUCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

START:

.IFDEF VERBOSE_LOGS
	_LOG_FILE .LOGFILENAME // UNCOMMENT TO SEND VERBOSE LOGS TO FILE
.ENDIF

	// CHECK IF NUMBER OF PARAMETERS CORRECT
	LDR X1,[SP,0]
	CMP X1,3
	B.EQ FILE_GIVEN
	_EXIT 1

FILE_GIVEN:

	SUB SP,SP,16

	// GRAB FIRST ARGUMENT FOR BOOMER OBJECT FILE
	LDR X1,[SP,32]
	SUB X1,X1,LOAD_ADDRESS // CONVERT TO CHALK ZONE MEMORY COORDINATES
	_OPEN_RW X1
	STR X0,[SP,0]	// BOOMER FD AT [SP+0]
	
	// GRAB SECOND ARGUMENT FOR OUTPUT BINARY
	LDR X1,[SP,40]
	SUB X1,X1,LOAD_ADDRESS // CONVERT TO CHALK ZONE MEMORY COORDINATES
	_OPEN_CREATE_EXECUTE X1
	STR X0,[SP,8]	// BINARY FD AT [SP+8]

	LDR X0,[SP,0]
	// GET FILESIZE OF BINARY IMAGE
	_LSEEK X0, 160, SYS_SEEK_SET // LSEEK TO BYTE 160 FROM FILE START
	LDR X0,[SP,0]
	_READ X0, .IMAGE_SIZE, 8 // READ 8 BYTES
	
	MOV X0,.IMAGE_SIZE
	ADD X0,X0,LOAD_ADDRESS
	LDR X0,[X0]
	// (?) CONVERT TO SENSIBLE ENDIANNESS TODO MAYBE FOR LARGER FILESIZE
	LDR X0,[SP,0]
	_LSEEK X0, 64, SYS_SEEK_SET
	// LSEEK TO BYTE 64 FROM FILE START (START OF EMBEDDED BINARY)

	MOV X0,.IMAGE_SIZE
	ADD X0,X0,LOAD_ADDRESS
	LDR X6,[X0]
	ADD X6,X6,120
	// X6 WILL TRACK NUMBER OF BYTES LEFT TO WRITE/READ

.LOOP:
	SUBS X7,X6,BUFFER_SIZE
	// IF X7 IS NEGATIVE, GO TO FINAL READ/WRITE OP
	// OTHERWISE READ/WRITE THE BUFFER SIZE AND CONTINUE
	B.GT .CONTINUE	

	// READ DATA FROM BOOMER FILE
	LDP X0,X1,[SP,0]
	_READ X0, .BUFFER, X6

	// COPY DATA INTO OUTPUT BINARY
	_WRITE X1, .BUFFER, X6

.DONE:

	ADD SP,SP,16 // NOT REQ?
	// DELETE BOOMER FILE
	LDR X1,[SP,16]	
	SUB X1,X1,LOAD_ADDRESS
	_UNLINK X1
	_EXIT 0

.CONTINUE:

	// READ DATA FROM BOOMER FILE
	LDP X0,X1,[SP,0]
	_READ X0, .BUFFER, BUFFER_SIZE

	// COPY DATA INTO OUTPUT BINARY
	_WRITE X1, .BUFFER, BUFFER_SIZE

	SUB X6,X6,BUFFER_SIZE

	B .LOOP

.IFDEF VERBOSE_LOGS
.LOGFILENAME:
	.ASCII "log.file\0"
.ENDIF

.IMAGE_SIZE:
	.SPACE 8

.EQU BUFFER_SIZE,1024
.BUFFER:

END:
